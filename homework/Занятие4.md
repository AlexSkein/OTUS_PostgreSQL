# Отчет по домашке №4


1. создайте новый кластер 
    Инициализация кластера с помощью команды initdb или утилиты pg_ctl. Например, можно указать путь к каталогу с новым кластером: 
    
    ```postgresql
        initdb -D /var/lib/newctl/.
    ```
    ![pg](/img/4/1.jpg)

    Назначение порта — так как порт по умолчанию 5432 занят первым кластером, для второго нужно поменять его номер. Это делается в файле postgresql.conf, который расположен в папке второго кластера. За порт отвечает параметр port — с него нужно снять комментарий и указать другой номер порта, например 5442.
    
    Запуск второго кластера 
    
    ```postgresql
        pg_ctl -D /var/lib/newctl/ start.
    ```
    
    ![pg](/img/4/2.jpg)

1. зайдите в созданный кластер под пользователем postgres

    ```postgresql
        psql -U postgres -p 5442
    ```

    ![pg](/img/4/3.jpg)

1. создайте новую базу данных testdb

    ```postgresql
    create database testdb;
    \l
    ```

    ![pg](/img/4/4.jpg)

1. зайдите в созданную базу данных под пользователем postgres

    ```postgresql
     \c testdb 
    ```
    ![pg](/img/4/5.jpg)

1. создайте новую схему testnm

    ```postgresql
     create schema testnm;
     \dn
    ``` 

    ![pg](/img/4/6.jpg)

1. создайте новую таблицу t1 с одной колонкой c1 типа integer

    ```postgresql
    create table t1(c1 int);
    \dt
    ```
    ![pg](/img/4/7.jpg) 

1. вставьте строку со значением c1=1

    ```postgresql
    insert into t1(c1) values(1);
    ```
    ![pg](/img/4/8.jpg) 

1. создайте новую роль readonly

    ```postgresql
    create role readonly;
    ```
    ![pg](/img/4/9.jpg)
     
1. дайте новой роли право на подключение к базе данных testdb
```postgresql
grant connect on DATABASE testdb TO readonly;

```
![pg](/img/4/10.jpg)

1. дайте новой роли право на использование схемы testnm

```postgresql
grant usage on SCHEMA testnm to readonly;

```
![pg](/img/4/11.jpg)

1. дайте новой роли право на select для всех таблиц схемы testnm

```postgresql
grant SELECT on all TABLEs in SCHEMA testnm TO readonly;

```
![pg](/img/4/12.jpg)

1. создайте пользователя testread с паролем test123

```postgresql
grant SELECT on all TABLEs in SCHEMA testnm TO readonly;

```
![pg](/img/4/13.jpg)

1. дайте роль readonly пользователю testread

```postgresql
grant readonly TO testread;

```
![pg](/img/4/14.jpg)

1. зайдите под пользователем testread в базу данных testdb

```postgresql
\c testdb  testread

```
![pg](/img/4/15.jpg)

1. сделайте select * from t1;

```postgresql

select* from t1;

```
![pg](/img/4/16.jpg)

1. получилось? (могло если вы делали сами не по шпаргалке и не упустили один существенный момент про который позже)

    **Нет.**
    
1. напишите что именно произошло в тексте домашнего задания
    
    **Поскольку в задании было сказано создать таблицу, но не указано в какой схеме, мы создали ее без явного указания**
    **схемы. Соответственно таблица создалась в схеме public и доступа у роли readonly к данной таблице нет.**

1. у вас есть идеи почему? ведь права то дали?

    **Описал идеи выше**

1. посмотрите на список таблиц
1. подсказка в шпаргалке под пунктом 20
1. а почему так получилось с таблицей (если делали сами и без шпаргалки то может у вас все нормально)
1. вернитесь в базу данных testdb под пользователем postgres
1. удалите таблицу t1
1. создайте ее заново но уже с явным указанием имени схемы testnm

1. вставьте строку со значением c1=1

```postgresql

testdb=# drop table t1;
DROP TABLE
testdb=# create table testnm.t1(c1 int);
CREATE TABLE
testdb=# insert into testnm.t1(c1) values(1);
INSERT 0 1


```
![pg](/img/4/17.jpg)

1. зайдите под пользователем testread в базу данных testdb
1. сделайте select * from testnm.t1;
```postgresql
testdb=# \c testdb  testread
Вы подключены к базе данных "testdb" как пользователь "testread".
testdb=> select* from testnm.t1;
ОШИБКА:  нет доступа к схеме testnm
```
![pg](/img/4/18.jpg)

1. получилось?
   **Нет.**
1. есть идеи почему? если нет - смотрите шпаргалку
    **Нет. Посмотрел в шпаргалку. Понял, что все таблицы имеется в виду все существующие на текущий момент.**
1. как сделать так чтобы такое больше не повторялось? если нет идей - смотрите шпаргалку
    **Посмотрел в шпаргалку.**
1. сделайте select * from testnm.t1;
1. получилось?
1. есть идеи почему? если нет - смотрите шпаргалку
1. сделайте select * from testnm.t1;
1. получилось?
    **В общем понятно, что ALTER default будет действовать для новых таблиц а grant SELECT on all TABLEs in SCHEMA для существующих**
1. ура!
1. теперь попробуйте выполнить команду create table t2(c1 integer); insert into t2 values (2);
    **таблица создаласть в схеме public**
1. а как так? нам же никто прав на создание таблиц и insert в них под ролью readonly?
    **Видимо в public можно по умолчанию создавать всем пользователям.**
1. есть идеи как убрать эти права? если нет - смотрите шпаргалку
    **Посмотрел шпаргалку**
1. если вы справились сами то расскажите что сделали и почему, если смотрели шпаргалку - объясните что сделали и почему выполнив указанные в ней команды
1. теперь попробуйте выполнить команду create table t3(c1 integer); insert into t3 values (2);
    ![pg](/img/4/19.jpg)
1. расскажите что получилось и почему
    **У testread только что отобрали права на public, search_path все еще смотрит туда.**